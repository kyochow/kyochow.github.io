{"randomArticles":[{"articleTitle":"关于界面栈系统","articleAbstractText":"概述 游戏内，关于界面的跳转逻辑，一般是有一定规则的，例如  从主界面 打开全屏界面A 打开弹出框B 关闭A和B后，打开C 关闭C，弹出A，再弹出B 关闭界面B 关闭界面A 打开主界面 打开副本界面中，点击某副本 弹出副本详情，点开战 关闭所有界面，进入战斗场景 等战斗结束，弹结算界面，清理战场 弹回之前的副本和详情界面，并恢复当时的状态  很啰嗦，但是这比较常见的流程，这里面有什么可以抽象出来的？可以达成什么目标？ 目标  开发者不需要特别关注打开一个界面时，后面的界面是个什么状态 开发者不需要特别关注在关闭一个界面的时候，该打开什么界面(除非有特殊跳转) 进战斗前，开发者不必每个人都记录当前打开的界面 出战斗后，开发者并不需要自己打开进战斗前的界面 但是，界面内的还原工作，还是需要每个人自己做  抽象  界面类别：  A级全屏界面 B级半屏界面 C级不重要的弹出界面(确认框，飘字等)   记录一个当前已经打开的Main层的界面queue standBy 记录一个当前已关闭的所有界面，pageStack 正向打开逻辑  如果是打开半屏界面，别的事什么也不做 如果是打开全屏界面，那么之....","articleStatus":0,"articlePermalink":"/articles/2020/10/23/1603418345984.html","articleImg1URL":"https://b3logfile.com/bing/20190714.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"lua 热部署简版","articleAbstractText":"Why 我们在做lua开发的时候，一般的流程  写代码，Play Unity，到我们的功能，看看效果 发现又问题，修改代码 重新 Play，运行到我们的功能，看效果 循环2 - 3  有可改进的空间吗 lua支持热部署，不需要重启unity，重新打开该界面即可 关于热部署的核心技术点 1. 监听lua文件修改 写一个配置文件，标明哪些目录是被监听的，其他项目可以使用FileSystemWatcher，但是unity项目比较简单，AssetPostprocess即可 当文件有修改，获得修改的文件路径 2. 放弃现有lua环境中已经加载过的cache 根据得到的路径，得到lua路径，并且 package.loaded['{requirePath}']=nil  3. 重新require require('{requirePath}')  PS 这里面包含的技术点  在Lua中使用require进行模块的加载，被成功加载的模块会将这个模块的引用保存到package.loaded表中；在使用require进行模块加载的时候，会首先在package.loaded表中查找，检测这个模块是否被加载过....","articleStatus":0,"articlePermalink":"/articles/2020/10/21/1603245912000.html","articleImg1URL":"https://b3logfile.com/bing/20181203.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}